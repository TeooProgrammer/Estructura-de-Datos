\documentclass{scrreprt}
\usepackage[spanish]{babel} % Para que LaTeX use términos en español como "Índice"
\usepackage{color}
\usepackage{fancyhdr} % Para el encabezado y pie de página
\usepackage{amsmath} % Para las ecuaciones
\usepackage{listings} % Para el código
\usepackage{upquote}
\usepackage[top=2cm, bottom=1cm, left=2cm, right=2cm]{geometry}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  urlcolor=blue
}

\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
\definecolor{editorGray}{rgb}{0.95, 0.95, 0.95}
\definecolor{editorOcher}{rgb}{1, 0.5, 0}
\definecolor{editorGreen}{rgb}{0, 0.5, 0}
\definecolor{brown}{rgb}{0.69, 0.31, 0.31}
\definecolor{purple}{rgb}{0.38, 0.18, 0.81}
\definecolor{lightred}{rgb}{1,0.4,0.5}

% Configuración del estilo de código
\lstdefinelanguage{Java}{
    morekeywords={abstract, assert, boolean, break, byte, case, catch, char, class, const, continue, default, do, double, else, enum, extends, final, finally, float, for, goto, if, implements, import, instanceof, int, interface, long, native, new, null, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]'
}

\lstdefinestyle{java} {
    language=Java,
    basicstyle=\footnotesize\ttfamily,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{brown}\itshape,
    stringstyle=\color{editorOcher}\ttfamily,
    frame=single
}

% Configuración del encabezado
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Gonzalo Ulloa - Estructuras de Datos - 2024} % Encabezado con tu nombre y materia
\fancyhead[R]{\thepage} % Número de página en el extremo derecho
\renewcommand{\headrulewidth}{0.4pt} % Línea bajo el encabezado


\setcounter{secnumdepth}{2} % Mantener la numeración en las subsecciones
\renewcommand{\thesubsection}{\arabic{subsection}} % Solo numerar las subsecciones

\begin{document}

% Portada
\begin{titlepage}
    \centering
    {\Large\bfseries TRABAJO PRÁCTICO N°3\\[1cm] Búsqueda\\[2cm]}
    {\large \textbf{ESTRUCTURAS DE DATOS - 2024}\\[1cm]}
    {\large Alumno:\\[0.5cm] \bfseries GONZALO ALEJANDRO ULLOA\\[2cm]}
    {\large Profesores:\\[0.5cm] \bfseries HECTOR REINAGA\\FERNANDA DANIELA OYARZO\\MIRTHA FABIANA MIRANDA\\[2cm]}
    {\large UNPA - UARG}
\end{titlepage}

% Generar la tabla de contenidos con el título "Índice"
\renewcommand{\contentsname}{Índice} % Cambiar el título del índice
\addcontentsline{toc}{section}{Índice}
\setcounter{tocdepth}{3}
\tableofcontents
\newpage

% Contenido del trabajo
\section*{Desarrollo}
\addcontentsline{toc}{section}{Desarrollo}
\setcounter{subsection}{2}
\subsection{}
\addcontentsline{toc}{subsection}{Punto 3}
\subsubsection{b) Módulo}

\begin{lstlisting}[style=java]
import java.io.*;
public class ArchivoDeEnteros{
    RandomAccessFile enteros;
    int[] tablaHash;
    int tam = 101; // tamanio
    public ArchivoDeEnteros(String fisico){
        tablaHash = new int[tam];
        for (int i = 0; i < tam; i++) {
            tablaHash[i] = -1;
        }
        try {
            enteros = new RandomAccessFile(fisico, "rw");
            if (enteros.length() > 0) {
                enteros.seek(enteros.length());
            }
            for (int i = 0; i < 100; i++) {
                int n = (int) (Math.random() * (9999 - 1000 + 1) + 1000);
                enteros.writeInt(n);
            }
            guardarEnteros();
        } catch (IOException e){
            System.out.println(e.getMessage());
        }
    }
    private void guardarEnteros(){
        try {
            enteros.seek(0);
            while (enteros.getFilePointer() < enteros.length()) {
                int num = enteros.readInt();
                insertarEnTabla(num);
            }
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }
    }

    private int modulo(int clave){
        return clave % tam;
    }
    void insertarEnTabla(int numero){
        int hash = modulo(numero);
        while (tablaHash[hash] != -1) {
            hash = (hash + 1) % tam; // incremento
        }
        tablaHash[hash] = numero;
    }
    public void mostrarElementos(){
        System.out.println("Elementos:");
        for (int i = 0; i < tam; i++) {
            if (tablaHash[i] != -1) {
               System.out.println("Posicion " + i + ": " + tablaHash[i]);
            }
        }
    }
    public static void main(String[] args) {
        ArchivoDeEnteros archivo = new ArchivoDeEnteros("enteros.dat");
        archivo.mostrarElementos();
    }
}
\end{lstlisting}

\subsubsection{c) Medio Cuadrado}

\begin{lstlisting}[style=java]
import java.io.*;
public class ArchivoDeEnterosM{
    RandomAccessFile enteros;
    int[] tablaHash;
    int tam = 101; // tamanio
    public ArchivoDeEnterosM(String fisico){
        tablaHash = new int[tam];
        for (int i = 0; i < tam; i++){
            tablaHash[i] = -1;
        }
        try{
            enteros = new RandomAccessFile(fisico, "rw");
            if (enteros.length() > 0){
                enteros.seek(enteros.length());
            }
            for (int i = 0; i < 100; i++){
                int n = (int) (Math.random() * (9999 - 1000 + 1) + 1000);
                enteros.writeInt(n);
            }
            guardarEnteros();
        } catch (IOException e){
            System.out.println(e.getMessage());
        }
    }
    private void guardarEnteros(){
        try{
            enteros.seek(0);
            while (enteros.getFilePointer() < enteros.length()){
                int num = enteros.readInt();
                insertarEnTabla(num);
            }
        } catch (IOException e){
            System.out.println(e.getMessage());
        }
    }
    private int medioCuadrado(int clave){
        int cuadrado = clave * clave;
        String cuadradoStr = String.valueOf(cuadrado);
        int medioInicio = (cuadradoStr.length() / 2) - 1;
        int medioFin = medioInicio + 2;
        int digitosCentrales = Integer.parseInt(cuadradoStr.substring(medioInicio, medioFin));
        return digitosCentrales % tam;
    }
    void insertarEnTabla(int numero){
        int hash = medioCuadrado(numero);
        while (tablaHash[hash] != -1){
            hash = (hash + 1) % tam;
        }
        tablaHash[hash] = numero;
    }
    public void mostrarElementos(){
        System.out.println("Elementos:");
        for (int i = 0; i < tam; i++){
            if (tablaHash[i] != -1){
                System.out.println("Posicion " + i + ": " + tablaHash[i]);
            }
        }
    }
    public static void main(String[] args) {
        ArchivoDeEnterosM archivo = new ArchivoDeEnterosM("enteros.dat");
        archivo.mostrarElementos();
    }
}
\end{lstlisting}
\subsubsection{Análisis}
El \textbf{método del módulo} es eficiente y rápido cuando los datos están bien distribuidos, pero se pueden generar muchas colisiones si los números siguen un patrón.


Por ejemplo, si se quisieran almacenar elementos que van de mil en mil (1000, 2000, 3000, ...):

\begin{equation}
1000 \% 100 = 0
\end{equation}

\begin{equation}
2000 \% 100 = 0
\end{equation}

\begin{equation}
3000 \% 100 = 0
\end{equation}

En este caso se van a presentar demasiadas colisiones.


El \textbf{método del medio cuadrado} distribuye mejor los valores al extraer los dígitos centrales, lo que reduce las colisiones. Sin embargo, es más costoso en términos de cálculo y recursos.

Para datos aleatorios y tablas pequeñas, el \textit{método del módulo} es más eficiente debido a su menor costo de recursos.



\subsubsection{\textbf{Repositorio de GitHub}}

- \href{https://github.com/NejoBMG/TP3_EDA/blob/main/ArchivoDeEnteros.java}{Método del módulo}


- \href{https://github.com/NejoBMG/TP3_EDA/blob/main/ArchivoDeEnterosM.java}{Método del medio cuadrado}


%fin punto 3
\newpage
\subsection{}
\addcontentsline{toc}{subsection}{Punto 4}
\subsubsection{b) Rehashing cuadrático}

\begin{lstlisting}[style=java]
import java.io.*;
public class ArchivoDeEnterosC{
    RandomAccessFile enteros;
    int[] tablaHash;
    int tam = 101; // tamanio
    public ArchivoDeEnterosC(String fisico){
        tablaHash = new int[tam];
        for (int i = 0; i < tam; i++){
            tablaHash[i] = -1;
        }
        try{
            enteros = new RandomAccessFile(fisico, "rw");
            if (enteros.length() > 0){
                enteros.seek(enteros.length());
            }
            for (int i = 0; i < 100; i++){
                int n = (int) (Math.random() * (9999 - 1000 + 1) + 1000);
                enteros.writeInt(n);
            }
            guardarEnteros();
        } catch (IOException e){
            System.out.println(e.getMessage());
        }
    }
    private void guardarEnteros(){
        try{
            enteros.seek(0);
            while (enteros.getFilePointer() < enteros.length()){
                int num = enteros.readInt();
                insertarEnTabla(num);
            }
        } catch (IOException e){
            System.out.println(e.getMessage());
        }
    }
    private int hash(int clave){
        return (7 * clave + 1) % 10;
    }
    void insertarEnTabla(int numero){
        int hash = hash(numero);
        int i = 1;
        while (tablaHash[hash] != -1){
            hash = (hash + i * i) % tam; //rehashing cuadratico
            i++;
        }
        tablaHash[hash] = numero;
    }
    public void mostrarElementos(){
        System.out.println("Elementos:");
        for (int i = 0; i < tam; i++){
            if (tablaHash[i] != -1){
                System.out.println("Posicion " + i + ": " + tablaHash[i]);
            }
        }
    }
    public static void main(String[] args) {
        ArchivoDeEnterosC archivo = new ArchivoDeEnterosC("enteros.dat");
        archivo.mostrarElementos();
    }
}
\end{lstlisting}
\newpage
\subsubsection{c) Rehashing con doble dirección hash}

\begin{lstlisting}[style=java]
import java.io.*;
public class ArchivoDeEnterosR{
    RandomAccessFile enteros;
    int[] tablaHash;
    int tam = 101; // tamanio
    public ArchivoDeEnterosR(String fisico){
        tablaHash = new int[tam];
        for (int i = 0; i < tam; i++){
            tablaHash[i] = -1;
        }
        try{
            enteros = new RandomAccessFile(fisico, "rw");
            if (enteros.length() > 0){
                enteros.seek(enteros.length());
            }
            for (int i = 0; i < 100; i++){
                int n = (int) (Math.random() * (9999 - 1000 + 1) + 1000);
                enteros.writeInt(n);
            }
            guardarEnteros();
        } catch (IOException e){
            System.out.println(e.getMessage());
        }
    }
    private void guardarEnteros(){
        try{
            enteros.seek(0);
            while (enteros.getFilePointer() < enteros.length()){
                int num = enteros.readInt();
                insertarEnTabla(num);
            }
        } catch (IOException e){
            System.out.println(e.getMessage());
        }
    }
    private int hash1(int clave){
        return (7 * clave + 1) % tam; //H1(K) = (7K + 1) % 10
    }
    private int hash2(int clave){
        return 1 + (clave % (tam - 1)); //H2(K) = 1 + (K % (tam - 1))
    }
    void insertarEnTabla(int numero){
        int hash = hash1(numero);
        int incremento = hash2(numero);
        int i = 0;
        while (tablaHash[hash] != -1){
            hash = (hash + incremento) % tam;
            i++;
        }
        tablaHash[hash] = numero;
    }
    public void mostrarElementos(){
        System.out.println("Elementos:");
        for (int i = 0; i < tam; i++){
            if (tablaHash[i] != -1){
                System.out.println("Posicion " + i + ": " + tablaHash[i]);
            }
        }
    }
    public static void main(String[] args) {
        ArchivoDeEnterosR archivo = new ArchivoDeEnterosR("enteros.dat");
        archivo.mostrarElementos();
    }
}
\end{lstlisting}
\subsubsection{Análisis}

El \textbf{rehashing cuadrático} tiende a generar menos comparaciones al evitar patrones lineales en la resolucion de colisiones y esto puede resultar en menos comparaciones en promedio.

El \textbf{rehashing con doble dirección hash} puede ser más efectivo en términos de espacio, ya que distribuye las claves de manera diferente porque al usar otra funcion hash como incremento puede ayudar a evitar agrupamientos. Entonces la eficacia depende de la elección de la segunda función hash.

Ambos métodos pueden tener rendimientos similars pero en este contexto de una tabla de 100 elementos, el rehashing cuadrático podria ser el más adecuado



\subsubsection{\textbf{Repositorio de GitHub}}

- \href{https://github.com/NejoBMG/TP3_EDA/blob/main/ArchivoDeEnterosC.java}{Método de rehashing cuadrático}


- \href{https://github.com/NejoBMG/TP3_EDA/blob/main/ArchivoDeEnterosR.java}{Método de rehashing con doble dirección hash}

\newpage
\begin{thebibliography}{9}
\addcontentsline{toc}{section}{Bibliografía}
\bibitem{cormen2009}
Cormen, T., Leiserson, C., Rivest, R., \& Stein, C. (2009). \textit{Introduction to Algorithms} (3rd ed.). MIT Press. ISBN: 978-0262033848. Recuperado de:
\url{https://drive.google.com/file/d/1mhixZxHUC1qU7bofbRgk6yeQLNQvfMEz/view}
\end{thebibliography}



\end{document}
